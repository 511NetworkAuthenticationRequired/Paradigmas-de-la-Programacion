# EXPRESIONES BOOLEANAS

En Pharo, los **operadores lógicos (booleanos)** pueden combinarse con **bloques**, permitiendo evaluación perezosa (lazy evaluation)[^1] para que los bloques solo se ejecuten si es necesario.

| OPERADOR | OPREACIÓN           | CONDICIÓN |
|:--------:|:-------------------:|:------------------------:
| and    | Conjunción            | Ambos operandos son verdaderos
| or    | Disyunción             | Al menos uno de los operandos es verdadero
| not   | Negación               | Invierte el valor de verdad de un solo operando (`true → false`, `false → true`).  

Estos operadores siguen estrictamente la **lógica booleana**, que se basa en valores de verdad `true` (V) y `false` (F).  

> [!TIP]
> ### TABLA DE VERDAD
>| A   | B   | A O B   | A Y B   |
>|----:|:---:|:-------:|:-------:|
>| V   | V   |    V    |    V    | 
>| V   | F   |    F    |    V    | 
>| F   | V   |    F    |    V    |
>| F   | F   |    F    |    F    |


## a.
```Smalltalk
5 < 2 or: [ $a isVowel ]
```
- `5 < 2` → `false`  
- Se evalúa el bloque `[ $a isVowel ]` → `true`  
- **Resultado:** `true`  

---

## b.
```Smalltalk
`5 < 2`
```
- Evaluación directa  
- **Resultado:** `false`  

---

## c.
```Smalltalk
`(5 < 2) not`
```

- Negación de `false` → `true`  
- **Resultado:** `true`  

---

## 
```Smalltalk
d. `5 < 2 and: [ $a isVowel ]`
```

- `5 < 2` → `false`  
- El bloque **no se ejecuta** porque el primer término ya es falso  
- **Resultado:** `false`  

---

## e. 
```Smalltalk
`(5 < 2) not and: [ $a isVowel ]`
```

- `(5 < 2) not` → `true`  
- Se evalúa el bloque `[ $a isVowel ]` → `true`  
- **Resultado:** `true`  

---

## f. 
```Smalltalk
`(5 < 2) not or: [ 'hola' size < 2 and: [ $a isVowel ] ]`
```

- `(5 < 2) not` → `true`  
- El bloque **no se ejecuta** porque el primer término ya es verdadero  
- **Resultado:** `true`

[^1]: Evaluación perezosa: es básicamente que Pharo solo calcula algo cuando realmente lo necesita, lo que sirve para ahorrar tiempo y evitar errores. Por ejemplo, en un `or:` si el primer término ya es `true`, Pharo ni toca el segundo, aunque tenga un error dentro. En Haskell, prácticamente todo es lazy por defecto.

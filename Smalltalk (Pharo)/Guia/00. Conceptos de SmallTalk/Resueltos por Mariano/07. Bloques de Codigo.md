# BLOQUES DE CÓDIGO

Un bloque en Pharo es un fragmento de código encerrado entre corchetes ` [ ... ]` que funciona como una función anónima[^1]. Es un objeto de primera clase, lo que significa que puede almacenarse en variables, pasarse como argumento a otros métodos y ejecutarse más tarde. Para ejecutar un bloque se utiliza el mensaje value, el cual evalúa el código contenido y devuelve el resultado. Los bloques pueden recibir argumentos, permitiendo encapsular lógica flexible que depende de valores externos.

Además, los bloques se usan ampliamente para control de flujo, iteraciones y filtros sobre colecciones. Al ser objetos, se pueden combinar con cualquier método de objetos y permiten operaciones concisas sobre caracteres, números y otras colecciones. Por ejemplo, se pueden usar con métodos como isVowel para evaluar condiciones sobre caracteres, o dentro de métodos de colección como select: para filtrar elementos según algún criterio.

En resumen, los bloques son una herramienta fundamental en Pharo que permite encapsular lógica que se ejecuta bajo demanda, hacer el código más flexible y aprovechar la orientación a objetos incluso en operaciones pequeñas o condicionales.

---

## a. y b.
```Smalltalk
[ $a isVowel ] value
```

**Devuelve:** `true`

`isVowel` permite saber si un caracter es o no una vocal, retornando `true` en caso de que lo sea. Por eso mismo, si se hace `[ $B isVowel ] value` va a devolver `false`. No importa si la letra (carácter) esta en mayúscula o minúscula, detecta igual.

---

## c.
```Smalltalk
[ 3+4. 'hola' asUpperCase ] value
```

**Devuelve:** `'HOLA'`

Notése que la última expresión dentro del bloque es la que determina el valor que devuelve al ejecutar `.value`. Las expresiones se pueden separar con `.` siempre que haya un espacio o salto de línea adecuado, de lo contrario da error.

---

## d.
```Smalltalk
| bloque |
bloque:=[ 'Hola ', ' como estás ?' ].
 ^bloque value.
```

**Devuelve:** ` como estás ?'`

En este ejemplo:
- `| bloque |` declara una **variable temporal** llamada `bloque`.  
- `bloque := [ 'Hola ' , ' como estás ?' ]` asigna un **bloque de código** que concatena dos strings.  
- `^bloque value` ejecuta el bloque y devuelve el resultado de la **última expresión**, que es la concatenación `'Hola como estás ?'`.

> [!TIP]
> En un bloque, la última expresión determina el valor de retorno, y hay que asegurarse de que sea una expresión que produzca el resultado deseado.

---

## e. y f.
```Smalltalk
[ :c | c isVowel ] value: $a
```

**Devuelve:** `true`

Esto define un bloque de código que recibe un argumento `c`. Retorna `true` solo si c es una vocal. A su vez, `.value: $a` ejecuta el bloque pasándole `$a` como argumento. El bloque evalúa `$a isVowel → true`.

Si el caracter que va después del `value:` NO es una vocal, va a devolver `false`, como en este caso:

```Smalltalk
[ :c | c isVowel ] value: $b
```

> [!TIP]
> El formato de los bloques se puede resumir en `[ :nombre_variable | condicion ] value: valor`.

---

## g.
```Smalltalk
| bloque resp |
  bloque:=[ :a :b | a , b].
resp:=bloque value: 'Hola ' value: ' como estás ?'.
^resp
```

**Devuelve:** `Hola  como estás ?`

Explicación:
1. `bloque := [ :a :b | a , b ]`
   + Define un bloque con dos parámetros a y b.
   +  Devuelve la concatenación a , b.
2. `resp := bloque value: 'Hola ' value: ' como estás ?'`
   + Ejecuta el bloque, pasando `'Hola '` como a y `' como estás ?'` como b.
   + El bloque concatena los dos strings.
7. `^resp`
   + Retorna el resultado final `'Hola como estás ?`'.

> [!NOTE]
> `value:` para un argumento, `value:value:` para dos argumentos, y así sucesivamente.

[^1]: **Función Anónima:** función o bloque de código que no tiene nombre asignado y sirve para encapsular lógica de manera temporal, sin necesidad de definir un método con nombre. En otros lenguajes, como python, se suele llamar lambda

# CLASES

En Pharo, **cada objeto pertenece a una clase**, que define su comportamiento y los mensajes que entiende. Como ya vimos antes, podemos usar `object class` para averiguar la clase de cualquier objeto.

---

## a.
```smalltalk
#(Francesca Jackie Marisa Bree) class
```

**Devuelve:** `Array`  
- Este ya vimos varias veces, pero es un **arreglo de símbolos**, los arrays en Pharo son colecciones indexadas que pueden contener cualquier tipo de objeto.

---

## b.
```smalltalk
'Rakesh Vijay Charles Daniel Tyler' class
```

**Devuelve:** `String` (`ByteString`)  
- Los strings en Pharo son secuencias de bytes que representan caracteres. `ByteString` es la clase más común para texto estándar, pero como vimos también hay otras, dependiendo del contenido del string.

---

## c.
```smalltalk
5 class
```

**Devuelve:** `SmallInteger`  
- `SmallInteger` representa **enteros pequeños** que se almacenan directamente en el objeto (sin puntero adicional).  
- Para enteros más grandes se usan `LargePositiveInteger` o `LargeNegativeInteger`.

> [!IMPORTANT]
> En Pharo, los SmallInteger tienen un rango limitado: en una VM[^1] de 64 bits, van aproximadamente desde $-2^{62}$ hasta $2^{62}-1$. Cuando un entero supera ese rango, Pharo lo convierte automáticamente en un `LargePositiveInteger` si es mayor que el máximo, o en un `LargeNegativeInteger` si es menor que el mínimo. Así, cualquier número que no quepa en un SmallInteger se maneja con estas clases grandes, que siguen comportándose como enteros normales, pero permiten valores mucho mayores sin límite práctico aparte de la memoria disponible.

---

## d.
```smalltalk
(1/2) class
```

**Devuelve:** `Fraction`  
- Los fractions representan **números racionales exactos** como `numerador/denominador`.  

 > [!NOTE]
 > Si ponés `1/2` sin paréntesis en un contexto donde se requiere prioridad, podría dar error porque `/` es mensaje de división.

---

## e.
```smalltalk
5.2 class
```

**Devuelve:** `Float` (`Float64`)  
- Los floats son **números en coma flotante** de doble precisión (`64 bits`).  
- Pharo también tiene `Float32` para precisión simple, pero `Float64` es estándar para cálculos numéricos precisos.

> [!IMPORTANT]
> En Pharo, los números en coma flotante pueden representarse con **distinta precisión**. La clase `Float32` permite almacenar números de precisión simple, usando menos memoria pero con menor exactitud en los cálculos. Por otro lado, `Float64` es la representación estándar de doble precisión y se utiliza habitualmente para cálculos numéricos que requieren mayor exactitud y estabilidad, como operaciones científicas o financieras. Así, aunque `Float32` puede ser útil en contextos donde la memoria es limitada o la precisión no es crítica, `Float64` garantiza resultados más confiables y consistentes en la mayoría de las aplicaciones.



[^1]: En este contexto, VM significa Virtual Machine o Máquina Virtual, que es básicamente el programa que ejecuta el código de Pharo.

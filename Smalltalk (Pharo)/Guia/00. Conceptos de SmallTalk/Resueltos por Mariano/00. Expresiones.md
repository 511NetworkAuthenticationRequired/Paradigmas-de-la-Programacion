# EXPRESIONES

> [!NOTE]
> Version de Pharo: 8.0

## a.
```smalltalk
5 + 6
```
**Devuelve:** 11  
---

## b.
```smalltalk
20 factorial
```
**Devuelve:** 2432902008176640000

> [!IMPORTANT]
>  Con `Ctrl + P` se imprime (ambos funcionan), pero con `Ctrl + Shift + G`, `'20 factorial'` no funciona porque no pertenece a ningún método guardado en una clase.

---

## c.
```smalltalk
'Esto es una prueba' size
```
**Devuelve:** 18
En este ejemplo, se trabaja con una cadena de texto (string), la expresión `'Esto es una prueba'`. El mensaje `size` se envía al string, y lo que hace es contar y devolver la cantidad total de caracteres que contiene (18, **incluyendo** espacios).
Es decir:
- `Esto` → 4 caracteres  
- espacio → 1 carácter   
- `es` → 2 caracteres  
- espacio → 1 carácter  
- `una` → 3 caracteres  
- espacio → 1 carácter  
- `prueba` → 6 caracteres  

**Total:** 4 + 1 + 2 + 1 + 3 + 1 + 6 = **18**

---

## d.
```smalltalk
#(1 3 5 7) at: 2
```
**Devuelve:** 3

Se accede al segundo elemento del array literal `#(1 3 5 7)`. En Pharo, las colecciones indexan desde 1, por lo que `at: 2` devuelve el valor en la segunda posición, que es `3`.

---

## e.
```smalltalk
'Paradigmas' isArray
```
**Devuelve:** `false`

En el código se pregunta si `'Paradigmas'` es un arreglo (Array) pero, como en realidad es un string, el resultado es false.

> [!CAUTION]
> La versión de la guía, `‘Paradigmas’`, da error porque tiene comillas curvas y esos caracteres no son reconocidos.

También se puede lograr lo mismo con:
```smalltalk
'Paradigmas' class = Array
```
Esta expresión compara la clase exacta del objeto con la clase Array. Devuelve true **solo** si el objeto es exactamente un Array, no si es una subclase o una instancia de alguna clase hija.

```smalltalk
'Paradigmas' isKindOf: Array
```
Esta expresión verifica si el objeto es una instancia de la clase Array o de **cualquiera** de sus subclases. Es decir, es una consulta más flexible sobre la jerarquía de clases. También devuelve `false` porque `'Paradigmas' ` no pertenece a la jerarquía de Array.

---

## f.
```smalltalk
5 * 7
```
**Devuelve:** 35  
Multiplica 5 por 7 y devuelve 35. El funcionamiento es el mismo que con la suma `5 + 6`, aplicando un operador aritmético básico.

---

## g.
```smalltalk
5 // 2
```
**Devuelve:** 2  
El operador `//` realiza una división entera, también conocida como división larga, donde se obtiene solo el cociente entero sin considerar el residuo o parte decimal. En Pascal, esta operación equivale al operador `DIV`.

---

## h.
```smalltalk
4 \\ 3
```
**Devuelve:** 1
El operador `\\` calcula el resto o residuo de la división entera entre dos números.
Esto es conocido como el operador módulo. En Pascal, esta operación corresponde al operador `MOD`.

---

## i.
```smalltalk
2 / 6
```
**Devuelve:** (1/3)  
En Pharo, la división entre enteros devuelve un **racional** en forma de fracción, no un número decimal.  
El resultado es una instancia de `Fraction` con:  
- `numerator` (numerador) igual a 1  
- `denominator` (denominador) igual a 3  

Para obtener un resultado en formato decimal (float), se puede forzar la conversión de dos maneras:

```smalltalk
(2 / 6) asFloat
```
**Resultado:** 0.3333333...

O bien:

```smalltalk
2 / 6.0
```
**Resultado:** 0.3333333...

> [!NOTE]
> Al usar un número decimal (6.0) en la operación, Pharo devuelve automáticamente un valor en coma flotante.

---

## j.
```smalltalk
1.5 + 6.3e2
```
Devuelve: **631.5**

Se utiliza notación científica donde `6.3e2` significa $6.3 \times 10^2$, es decir, 630.  
La operación suma `1.5 + 630`, dando como resultado **631.5**.

---

## k.
```smalltalk
Array new
```
**Devuelve:** `#()`, es decir, un arreglo vacío.

Por otro lado, si quiero un arreglo de n posiciones:
### Sea n = 3
```smalltalk
Array new: 3
```

**Devuelve:** `#(nil nil nil)`

Devuelve un arreglo de 3 posiciones. Como no tiene nada cargado, todas las posiciones contienen `nil` (concepto de nuladidad de Pharo).

> [!CAUTION]
> `nil` no es lo mismo que `0`, para tener `0` en todas las posiciones del arreglo se debería cargar de 0.

Se puede crear un arreglo ya precargado:
```smalltalk
#(0 0 0)
```
Esto basicamente pone a `0` completamente a un vector de 3 posiciones.

---

## l.
```smalltalk
Date today
```

Devuelve la fecha actual del sistema. También se puede usar `yesterday`, etc. Usa la fecha del sistema como referencia.

---

## m.
```smalltalk
Time now
```

Devuelve la hora actual en formato `hh:mm:ss.ffffffff am/pm`.
